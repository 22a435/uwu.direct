<!DOCTYPE html>
<!-- 🏴🏴🏴🏴🏴🏴🏴🏴 -->
<!-- extremely alpha software and illiquid markets. yolo with care -->
<!-- report bugs and request features / UI/UX improvements to prioritize in -->
<!-- http://t.me/unicorn_black_market -->
<!-- 🏴🏴🏴🏴🏴🏴🏴🏴 -->
<html>
<head><meta charset="UTF-8">


<style>
    table,
    th,
    td {
        border: 1px solid black;
        margin-left: auto;
        margin-right: auto
    }
</style>
    <script>
        (function () { var PREFIXES = { 24: "Sp", 21: "Sx", 18: "Qn", 15: "Qd", 12: "T", 9: "B", 6: "M", 3: "k", 0: "", "-3": "m", "-6": "µ", "-9": "n", "-12": "p", "-15": "f", "-18": "a", "-21": "z", "-24": "y" }; function getExponent(n) { if (n === 0) { return 0 } return Math.floor(Math.log10(Math.abs(n))) } function precise(n) { return Number.parseFloat(n.toPrecision(3)) } function toHumanString(sn) { var n = precise(Number.parseFloat(sn)); var e = Math.max(Math.min(3 * Math.floor(getExponent(n) / 3), 24), -24); return precise(n / Math.pow(10, e)).toString() + PREFIXES[e] } var HRNumbers = { toHumanString: toHumanString }; if (typeof define == "function" && define.amd) { define([], function () { return HRNumbers }) } else if (typeof exports != "undefined") { exports = module.exports = HRNumbers } else { this.HRNumbers = HRNumbers } }).call(this);
    </script>
    <script>

    </script>
    <script>
        const q = { "pairs": { "limit": 100 } };

    </script>
    <script>
        // var pf = new Intl.NumberFormat(options = { "style": "percent" });
        const sizeRatio = 0.20;
        // var balances = {};
        var supply_ = new Map();
        var balances_ = new Map();
        var pairs_ = new Map();
        var lpadrs_ = new Map();
        // var hrn;
        var client;
        var stargate;
        var walletAddress;
        var cosmwasm_stargate;
        var stargate;
        var tx_types;
        const chainId = "unicorn-420"
        const rest = "https://rest.unicorn.meme";
        const rpc = "https://rpc.unicorn.meme";
        const bank = "/cosmos/bank/v1beta1/";
        const wasm = "/cosmwasm/wasm/v1/contract/";
        const router = "unicorn16jzpxp0e8550c9aht6q9svcux30vtyyyyxv5w2l2djjra46580wsl825uf";
        const factory = "unicorn1yvgh8xeju5dyr0zxlkvq09htvhjj20fncp5g58np4u25g8rkpgjslkfelc";
        const devliq = "unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty";
        const emoji = {
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ualien": "👽",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ubear": "ʕ·͡ᴥ·ʔ",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ubearhearth": "ʕっ•ᴥ•ʔっ❤️",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ublackflag": "🏴",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ublissful": "(｡◕‿‿◕｡)",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ublowfish": "🐡",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ucash": "💸",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ucat": "🐱",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uchains": "🙂⛓️",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uchick": "🐤",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uchina": "🇨🇳",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uclown": "🤡",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ucorn": "🌽",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ucrystalball": "🔮",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/udiamond": "💎",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/udice": "🎲",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/udog": "🐶",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ueggplant": "🍆",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ueightball": "🎱",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uenvelop": "✉️",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ufahrenheit": "🔥",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ufrog": "🐸",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ugun": "▄︻デ══‐一♡",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/umeat": "🥩",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/umog": "😹",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/umoon": "🌕",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uorwell": "🐷",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/upaper": "📄",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/upeace": "🌎☮️",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/upeach": "🍑",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/upi": "🥧",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uplaceholder": "placeholder",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/upoo": "💩",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/upretzel": "🥨",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uretard": "🫵🤡",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/urock": "🪨",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/urocket": "🚀",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/usa": "🇺🇸",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uscisors": "✂️",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ushot": "💉🧬",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ushrimp": "🦐",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uskull": "💀",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/usushi": "🍣",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/utaco": "🌮",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/utaiwan": "🇹🇼",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/utest": "test",
            "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/uwatermelon": "🍉",
            "uwunicorn": "🦄"
        };
        function suggest(sup_res) {
            const cur = sup_res.map((sup) => {
                return {
                    coinMinimalDenom: sup.denom,
                    coinDenom: emoji[sup.denom],
                    coinDecimals: 6
                };
            })
            return window.leap.experimentalSuggestChain({
                chainId: chainId,
                chainName: "unicorn",
                rest: rest,
                rpc: rpc,
                bip44: {
                    coinType: 118,
                },
                bech32Config: {
                    bech32PrefixAccAddr: "unicorn",
                    bech32PrefixAccPub: "unicorn" + "pub",
                    bech32PrefixValAddr: "unicorn" + "valoper",
                    bech32PrefixValPub: "unicorn" + "valoperpub",
                    bech32PrefixConsAddr: "unicorn" + "valcons",
                    bech32PrefixConsPub: "unicorn" + "valconspub",
                },
                currencies: cur,
                feeCurrencies: [
                    {
                        coinDenom: "🦄",
                        coinMinimalDenom: "uwunicorn",
                        coinDecimals: 6,
                        gasPriceStep: {
                            low: 0.01,
                            average: 0.025,
                            high: 0.04,
                        },
                    },
                ],
                stakeCurrency: {
                    coinDenom: "🦄",
                    coinMinimalDenom: "uwunicorn",
                    coinDecimals: 6
                },
                features: ["cosmwasm"]
            });
        }
        async function supply() {
            const res = await fetch(rest + bank + "supply?pagination.limit=100");
            const tx = await res.text();
            return JSON.parse(tx).supply;
        }

        async function getSupply() {
            var s = await supply();
            var m = new Map();
            s.forEach(si => m.set(si.denom, parseInt(si.amount)));
            return m;
        }

        async function load() {
            supply_ = await getSupply();
            
            var memeDenoms = Array.from(supply_.keys()).filter(d => d !== "uwunicorn");
      
            var minters = new Set(memeDenoms.map(d => d.split('/')[1]));
   
            await Promise.all(memeDenoms.map(d => get_pair(d)))
    
            var waddrs = [walletAddress].concat(Array.from(minters), Array.from(pairs_.values()));

            await Promise.all(waddrs.map(a => get_balances(a)));

        }

        async function get_balances(address) {
            var adrbal;
            if (address in balances_) { adrbal = balances_[address]; } else {
                const res = await fetch(rest + bank + "balances/" + address);
                const tx = await res.text();
                adrbal = new Map();
                JSON.parse(tx).balances.forEach(b => {
                    adrbal.set(b.denom, parseInt(b.amount) / 1000000);
                });
                balances_[address] = adrbal;
            }
            return adrbal;
        }
        async function get_balance(address, denom) {
            var adrbal;
            if (address in balances_) { adrbal = balances_[address]; } else {
                adrbal = new Map();

                try {
                    const res = await fetch(rest + bank + "balances/" + address);
                    const tx = await res.text();
                    JSON.parse(tx).balances.forEach(b => {
                        adrbal.set(b.denom, parseInt(b.amount) / 1000000);
                    });
                    balances_.set(address, adrbal);
                } catch (error) {
                    console.log(error)
                }
            }
            if (adrbal.has(denom)) { return adrbal.get(denom); } else { return 0; }
        }
        async function price(denom) {
            var p = await get_pair(denom);
            var ubal = await get_balance(p, "uwunicorn");
            var dbal = await get_balance(p, denom);
            return ubal / dbal;
        }
        async function get_pair(denom) {
            if (pairs_.has(denom)) { return pairs_.get(denom); } else {
                try {
                    const res = await fetch(rest + wasm + factory + "/smart/" + btoa(JSON.stringify({
                        "pair": {
                            "asset_infos": [
                                { "native_token": { "denom": denom } },
                                { "native_token": { "denom": "uwunicorn" } }
                            ]
                        }
                    })));
                    const tx = await res.text();
                    const j = JSON.parse(tx);
                    const p = j.data.contract_addr;
                    const lp = j.data.liquidity_token;
                    pairs_.set(denom, p);
                    lpadrs_.set(denom, lp)
                    return p;
                } catch (error) {
                    console.log(error)
                    return ""
                }
            }
        }
        async function get_lp(d, a) {
            if (!lpadrs_.has(d)) {
                await get_pair(d);
            }
            try {
                const lp = lpadrs_.get(d);
                const res = await fetch(rest + wasm + lp + "/smart/" + btoa(JSON.stringify({
                    "balance":{"address":a}
                })));
                const tx = await res.text();
                const j = JSON.parse(tx);
                return parseInt(j.data.balance);
            } catch (error) {
                console.log(error);
                return 0;
            }
        }
        async function get_total_lp(d) {
            const p = await get_pair(d);
            try {
                const res = await fetch(rest + wasm + p + "/smart/" + btoa(JSON.stringify({
                    "pool":{}
                })));
                const tx = await res.text();
                const j = JSON.parse(tx);
                return parseInt(j.data.total_share);  
            } catch (error) {
                console.log(error)
                return 0;
            }
        }
        async function tvl(denom) {
            var p = await get_pair(denom);
            var res = await get_balance(p, "uwunicorn");
            return res;
        }
        async function info(addr, sup) {
            var d = sup.denom;
            var s = parseInt(sup.amount) / 1000000;
            var b = await get_balance(addr, d);
            var not_circ = await get_balance(devliq, d);
            var circ = s - not_circ;
            // balances[d] = b;
            var r = b / circ;
            if (d == "uwunicorn") {
                return {
                    "denom": "uwunicorn",
                    "emoji": "🦄",
                    "supply": s,
                    "circ": s,
                    "mcap": s,
                    "fdv": s,
                    "tvl": 0,
                    "liq": 0,
                    "liqshare": 1,
                    "price": 1,
                    "balance": b,
                    "share": r,
                    "value": b
                };
            } else {
                var ml = await get_lp(sup.denom, walletAddress);//make func of denom later
                var tl = await get_total_lp(sup.denom);
                var t = await tvl(d)
                var p = await price(d);
                return {
                    "denom": d,
                    "emoji": emoji[d] ? emoji[d] : d,
                    "supply": s,
                    "circ": circ,
                    "mcap": (p * circ),
                    "fdv": (p * s),
                    "tvl": await tvl(d),
                    "liq": t / (p * circ),
                    "liqshare": ml/tl,
                    "price": p,
                    "balance": b,
                    "share": r,
                    "value": (b * p)
                }
            }
        }

        async function swap(d_in, d_out, size) {
            alert("test swap please ignore");
            var msg = {
                "execute_swap_operations": {
                    "max_spread": "0.5",
                    "minimum_receive": "1",
                    "operations": [{
                        "astro_swap": {
                            "offer_asset_info": { "native_token": { "denom": d_in } },
                            "ask_asset_info": { "native_token": { "denom": d_out } }
                        }
                    }]
                }
            };
            var res = await client.execute(walletAddress, router, msg, "auto", "", [{
                denom: d_in, amount: size
            }]);
            alert("https://uwu.direct/Unicorn/tx/"+res.transactionHash);
        }

        async function loadClient() {
            await window.leap.enable(chainId);
            cosmwasm_stargate = await import("https://esm.run/@cosmjs/cosmwasm-stargate@0.27.0");
            stargate = await import("https://esm.run/@cosmjs/stargate@0.27.0");
            proto_signing = await import("https://esm.run/@cosmjs/proto-signing@0.27.0");
            tx_types = await import("https://esm.run/cosmjs-types/cosmwasm/wasm/v1/tx");
            const offlineSigner = await window.leap.getOfflineSignerAuto(chainId);
            const accounts = await offlineSigner.getAccounts();
            client = await cosmwasm_stargate.SigningCosmWasmClient.connectWithSigner(
                rpc,
                offlineSigner,
                {gasPrice: stargate.GasPrice.fromString("0.001uwunicorn")}
            )
        }
        window.onload = async () => {
            var params = new URLSearchParams(window.location.search);
            var d_in = params.get("d_in");
            var d_out = params.get("d_out");
            var size = params.get("size")

            d_in ??= "uwunicorn";
            d_out ??= "factory/unicorn1rn9f6ack3u8t3ed04pfaqpmh5zfp2m2ll4mkty/ublackflag";
            size ??= "1000000";

            document.getElementById("size").value = size;
            const sup_res = await supply();
            await suggest(sup_res);
            await loadClient();

            var key = await window.leap.getKey(chainId);
            

            walletAddress = key.bech32Address;
            await load();
            var infos = await Promise.all(sup_res.map((x) => info(walletAddress, x)));
            infos.sort((a, b) => b.tvl - a.tvl);
            const insel = document.getElementById("inselector");
            const outsel = document.getElementById("outselector");
            const market = document.getElementById("market");
            infos.forEach(i => {
                var inopt = document.createElement("option");
                inopt.value = i.denom;
                if (i.denom == d_in) {
                    inopt.selected = "selected";
                }
                inopt.innerHTML = emoji[i.denom] ? emoji[i.denom] : i.denom;
                insel.appendChild(inopt);

                var outopt = document.createElement("option");
                outopt.value = i.denom;
                if (i.denom == d_out) {
                    outopt.selected = "selected";
                }
                outopt.innerHTML = emoji[i.denom] ? emoji[i.denom] : i.denom;
                outsel.appendChild(outopt);

                let row = market.insertRow();
                // row.insertCell(0).innerHTML = i.denom;
                row.insertCell(0).innerHTML = i.emoji;
                row.insertCell(1).innerHTML = HRNumbers.toHumanString(i.supply);
                row.insertCell(2).innerHTML = HRNumbers.toHumanString(i.circ);

                row.insertCell(3).innerHTML = HRNumbers.toHumanString(i.mcap);
                row.insertCell(4).innerHTML = HRNumbers.toHumanString(i.fdv);
                row.insertCell(5).innerHTML = HRNumbers.toHumanString(i.tvl);
                row.insertCell(6).innerHTML = i.liq.toLocaleString(undefined,{style: 'percent', minimumFractionDigits:3 });
                row.insertCell(7).innerHTML = i.liqshare.toLocaleString(undefined,{style: 'percent', minimumFractionDigits:3 });
                row.insertCell(8).innerHTML = i.price.toLocaleString(undefined,{ minimumSignificantDigits:3, maximumSignificantDigits:5});

                row.insertCell(9).innerHTML = HRNumbers.toHumanString(i.balance);
                row.insertCell(10).innerHTML = i.share.toLocaleString(undefined,{style: 'percent', minimumFractionDigits:3 });
                
                row.insertCell(11).innerHTML = HRNumbers.toHumanString(i.value);

                row.insertCell(12).innerHTML = HRNumbers.toHumanString(i.liqshare*i.tvl*2);

            });
            var hax = params.get("hax");
            if (hax == "prov") {
                var denom_m = params.get("denom_m");
                var size_m = params.get("size_m");
                var size_u = params.get("size_u");
                await prov(denom_m, size_m, size_u);
            } else {
                await swap(d_in, d_out, size);
            }

        }
        async function prov(denom_m, size_m, size_u) {
            alert("test prov please ignore");
            var msg = {
                "provide_liquidity": {
                    "auto_stake": false,
                    "slippage_tolerance": "0.5",
                    "assets": [
                        {
                            "amount": size_m,
                            "info": { "native_token": { "denom": denom_m } }
                        },
                        {
                            "amount": size_u,
                            "info": { "native_token": { "denom": "uwunicorn" } }
                        }
                    ]
                }
            };
            var pool = await get_pair(denom_m);
            var res = await client.execute(walletAddress, pool, msg, "auto", "", [{
                denom: denom_m, amount: size_m
            }, {
                denom: "uwunicorn", amount: size_u
            }]);
            alert("https://uwu.direct/Unicorn/tx/"+res.transactionHash);
        }
    </script>
</head>
<body>
    <table id="terminal">
        <thead>
            <tr>
                <th>In</th>
                <th>Out</th>
                <th>Size (in uwunicorn / use 1000000x) </th>
                <th>Send It</th>
            </tr>
        </thead>
        <tr>
            <form action="/">
                <td><select name="d_in" id="inselector"></select></td>
                <td><select name="d_out" id="outselector"></select></td>
                <td><input name="size" id="size" default="0"></input></td>
                <td><button id="sendit">✅</button></td>
            </form>
        </tr>
    </table>
    <table id="market">
        <thead>
            <tr>
                <!-- <th>Base Denom</th> -->
                <th>Emoji</th>
                <th>Supply</th>
                <th>Circ</th>
                <th>MCap (🦄)</th>
                <th>FDV (🦄)</th>
                <th>TVL (🦄)</th>
                <th>Liq (TVL/MCap)</th>
                <th>Wallet Liq</th>
                <th>Price (🦄)</th>
                <th>Balance</th>
                <th>Share (Bal/Circ)</th>
                <th>Value (🦄)</th>
                <th>Liq Value (🦄)</th>
            </tr>
        </thead>
    </table>
</body>

</html>
